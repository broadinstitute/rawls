package org.broadinstitute.dsde.rawls.dataaccess

import java.net.InetAddress

import com.typesafe.config.ConfigFactory
import org.broadinstitute.dsde.rawls.model.{Submission, UserInfo}
import org.broadinstitute.dsde.rawls.util.ScalaConfig._
import org.broadinstitute.dsde.workbench.google.GoogleCredentialModes.Token
import org.broadinstitute.dsde.workbench.google.HttpGoogleBigQueryDAO
import org.broadinstitute.dsde.workbench.model.google.GoogleProject

import scala.concurrent.{ExecutionContext, Future}

class SubmissionCostService(val submission: Submission, val userInfo: UserInfo)(implicit val executionContext: ExecutionContext) {


  def getCostWithUser(workflowIds: Seq[String], userInfo: UserInfo): Future[Map[String, Float]] = {
//
//    // Much of the Config code below is copied from Boot.scala - is there a better way?
//    // version.conf is generated by sbt
//    val conf = ConfigFactory.parseResources("version.conf").withFallback(ConfigFactory.load())
//    val gcsConfig = conf.getConfig("gcs")
//    val appName = gcsConfig.getString("appName")
//
//    val metricsConf = conf.getConfig("metrics")
//    val metricsPrefix = {
//      val basePrefix = metricsConf.getString("prefix")
//      metricsConf.getBooleanOption("includeHostname") match {
//        case Some(true) =>
//          val hostname = InetAddress.getLocalHost.getHostName
//          basePrefix + "." + hostname
//        case _ => basePrefix
//      }
//    }
//
//    def getAccessToken: String = userInfo.accessToken.token
//
//    def queryString: String = "SELECT COUNT(*) AS scullion_count FROM publicdata.samples.shakespeare WHERE word='scullion'"
//
//    def googleProject: GoogleProject = ??? // I think rawls?
//
//    lazy val bigQueryDAO: HttpGoogleBigQueryDAO = new HttpGoogleBigQueryDAO(appName, Token(() => getAccessToken), metricsPrefix)
//
//    val rows = for {
//      jobRef <- bigQueryDAO.startQuery(googleProject, queryString)
//      job <- bigQueryDAO.getQueryStatus(jobRef)
//      result <- bigQueryDAO.getQueryResult(job)
//    } yield result.getRows
//
//    val result = rows flatMap { row =>
//      ???
//    }
    Future(Map("wf1" -> 2.00f))
  }
}
