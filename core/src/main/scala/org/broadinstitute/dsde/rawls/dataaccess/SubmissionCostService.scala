package org.broadinstitute.dsde.rawls.dataaccess

import java.net.InetAddress

import akka.actor.ActorSystem
import com.typesafe.config.ConfigFactory
import org.broadinstitute.dsde.rawls.model.{RawlsBillingProjectName, Submission, UserInfo}
import org.broadinstitute.dsde.rawls.util.ScalaConfig._
import org.broadinstitute.dsde.workbench.google.GoogleCredentialModes.Token
import org.broadinstitute.dsde.workbench.google.HttpGoogleBigQueryDAO
import org.broadinstitute.dsde.workbench.model.google.GoogleProject

import scala.concurrent.{ExecutionContext, Future}

object SubmissionCostService {
  def constructor(implicit executionContext: ExecutionContext, actorSystem: ActorSystem) =
    new SubmissionCostService
}

class SubmissionCostService(implicit val executionContext: ExecutionContext, implicit val actorSystem: ActorSystem) {

  def getWorkflowCosts(namespace: String,
                       workflowIds: Seq[String],
                       userInfo: UserInfo,
                       googleProject: GoogleProject): Future[Map[String, Float]] = {
    // Much of the Config code below is copied from Boot.scala - is there a better way?
    // I think this should be moved to Boot.scala and added to WorkspaceService constructor
    // version.conf is generated by sbt
    val conf = ConfigFactory.parseResources("version.conf").withFallback(ConfigFactory.load())
    val gcsConfig = conf.getConfig("gcs")
    val appName = gcsConfig.getString("appName")

    val metricsConf = conf.getConfig("metrics")
    val metricsPrefix = {
      val basePrefix = metricsConf.getString("prefix")
      metricsConf.getBooleanOption("includeHostname") match {
        case Some(true) =>
          val hostname = InetAddress.getLocalHost.getHostName
          basePrefix + "." + hostname
        case _ => basePrefix
      }
    }

    lazy val bigQueryDAO: HttpGoogleBigQueryDAO = new HttpGoogleBigQueryDAO(appName, Token(() => userInfo.accessToken.token), metricsPrefix)

    val tableName = "broad-gcp-billing:gcp_billing_export.gcp_billing_export_v1_001AC2_2B914D_822931"
    val subqueryTemplate = workflowIds.map(id => s"labels_value LIKE $id").mkString(" OR ")
    val queryString = s"SELECT GROUP_CONCAT(labels.key) WITHIN RECORD AS labels_key," +
                          " GROUP_CONCAT(labels.value) WITHIN RECORD labels_value," +
                          " cost, service.description, sku.description" +
                        s" FROM [$tableName]" +
                        s" WHERE project.id = '$namespace' AND labels.key IN" +
                          " (\"cromwell-workflow-id\"," +
                          " \"cromwell-workflow-name\"," +
                          " \"cromwell-sub-workflow-name\"," +
                          " \"wdl-task-name\"," +
                          " \"wdl-call-alias\")" +
                        s" HAVING $subqueryTemplate"
                        // uncomment for quick testing:
                        //+ " LIMIT 1"

    val rows = for {
      jobRef <- bigQueryDAO.startQuery(googleProject, queryString)
      job <- bigQueryDAO.getQueryStatus(jobRef)
      result <- bigQueryDAO.getQueryResult(job)
    } yield result.getRows

    val result = rows.map { row =>
      row.get(0).getF
    }

    Future(Map("wf1" -> 2.00f))
  }
}
