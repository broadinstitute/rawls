package org.broadinstitute.dsde.rawls.monitor.workspace.runners.clone

import com.typesafe.scalalogging.LazyLogging
import org.broadinstitute.dsde.rawls.dataaccess.{
  GoogleServicesDAO,
  LeonardoDAO,
  SamDAO,
  WorkspaceManagerResourceMonitorRecordDao
}
import org.broadinstitute.dsde.rawls.dataaccess.slick.WorkspaceManagerResourceMonitorRecord.{
  Complete,
  Incomplete,
  JobType
}
import org.broadinstitute.dsde.rawls.dataaccess.slick.{
  WorkspaceManagerResourceJobRunner,
  WorkspaceManagerResourceMonitorRecord
}
import org.broadinstitute.dsde.rawls.dataaccess.workspacemanager.WorkspaceManagerDAO
import org.broadinstitute.dsde.rawls.model.{
  AttributeBoolean,
  AttributeName,
  AttributeString,
  Workspace,
  WorkspaceRequest,
  WorkspaceState
}
import org.broadinstitute.dsde.rawls.monitor.workspace.runners.UserCtxCreator
import org.broadinstitute.dsde.rawls.workspace.WorkspaceRepository

import java.util.UUID
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

object WorkspaceCloningRunner {

  val WORKSPACE_INITIAL_CLONE_JOBID_KEY = "WORKSPACE_INITIAL_CLONE_JOBID"
  val SOURCE_WORKSPACE_KEY = "SOURCE_WORKSPACE"
  val STORAGE_CONTAINER_CLONE_PREFIX_KEY = "STORAGE_CONTAINER_CLONE_PREFIX"
  val DISABLE_AUTOMATIC_APP_CREATION_KEY = "DISABLE_AUTOMATIC_APP_CREATION"

  // The jobId returned by WSM is the default job id generated by stairway
  // Currently, stairway generates this via a 'ShortUUID' which doesn't parse correctly
  // So for the time being, we need to add it as a job argument
  def buildCloningArgs(sourceWorkspace: Workspace,
                       initialJobId: String,
                       request: WorkspaceRequest
  ): Map[String, String] = {
    val disableAutoAppCreate =
      request.attributes.get(AttributeName.withDefaultNS("disableAutomaticAppCreation")) match {
        case Some(AttributeString("true")) | Some(AttributeBoolean(true)) => "true"
        case _                                                            => "false"
      }

    val args = Map(
      WORKSPACE_INITIAL_CLONE_JOBID_KEY -> initialJobId,
      SOURCE_WORKSPACE_KEY -> sourceWorkspace.workspaceIdAsUUID.toString,
      DISABLE_AUTOMATIC_APP_CREATION_KEY -> disableAutoAppCreate
    )

    request.copyFilesWithPrefix match {
      case Some(prefix) => args + (STORAGE_CONTAINER_CLONE_PREFIX_KEY -> prefix)
      case None         => args
    }
  }

  def getInitialWSMJobId(args: Option[Map[String, String]]): Option[String] =
    args.flatMap(argsMap => argsMap.get(WORKSPACE_INITIAL_CLONE_JOBID_KEY))

  def isAutomaticAppCreationDisabled(args: Option[Map[String, String]]): Boolean =
    args.flatMap(argsMap => argsMap.get(DISABLE_AUTOMATIC_APP_CREATION_KEY)).getOrElse("false") == "true"

  def getSourceWorkspaceId(args: Option[Map[String, String]]): Option[UUID] =
    args.flatMap(argsMap => argsMap.get(SOURCE_WORKSPACE_KEY)).map(id => UUID.fromString(id))

  def getStorageContainerClonePrefix(args: Option[Map[String, String]]): Option[String] =
    args.flatMap(argsMap => argsMap.get(STORAGE_CONTAINER_CLONE_PREFIX_KEY))
}

class WorkspaceCloningRunner(
  val samDAO: SamDAO,
  val gcsDAO: GoogleServicesDAO,
  leonardoDAO: LeonardoDAO,
  workspaceManagerDAO: WorkspaceManagerDAO,
  monitorRecordDao: WorkspaceManagerResourceMonitorRecordDao,
  workspaceRepository: WorkspaceRepository
) extends WorkspaceManagerResourceJobRunner
    with LazyLogging
    with UserCtxCreator {

  def cloneFail(wsId: UUID, message: String)(implicit executionContext: ExecutionContext): Future[Int] =
    workspaceRepository.setFailedState(wsId, WorkspaceState.CloningFailed, message)

  override def apply(job: WorkspaceManagerResourceMonitorRecord)(implicit
    executionContext: ExecutionContext
  ): Future[WorkspaceManagerResourceMonitorRecord.JobStatus] = {
    def logFailure(msg: String, t: Option[Throwable] = None): Unit = {
      val logMessage = s"CloneWorkspace monitoring job with id ${job.jobControlId} failed: $msg"
      t match {
        case Some(t) => logger.error(logMessage, t)
        case None    => logger.error(logMessage)
      }
    }

    val workspaceId = job.workspaceId match {
      case Some(id) => id
      case None =>
        logger.error(
          s"Job to monitor workspace deletion created with id ${job.jobControlId} but no workspace ID"
        )
        return Future.successful(Complete)
    }

    val userEmail = job.userEmail match {
      case Some(email) => email
      case None =>
        val msg =
          s"Unable to update clone status for workspace $workspaceId because no user email set on monitoring job"
        logFailure(msg)
        return cloneFail(workspaceId, msg).map(_ => Complete)
    }

    getUserCtx(userEmail).transformWith {
      case Failure(t) =>
        val msg =
          s"Unable to retrieve clone workspace results for workspace $workspaceId: unable to retrieve request context for $userEmail"
        logFailure(msg, Some(t))
        cloneFail(workspaceId, msg).map(_ => Incomplete)
      case Success(userCtx) =>
        val step = getStep(job, workspaceId)
        step.runStep(userCtx)
    }
  }

  def getStep(job: WorkspaceManagerResourceMonitorRecord, workspaceId: UUID)(implicit
    executionContext: ExecutionContext
  ): WorkspaceCloningStep = job.jobType match {
    case JobType.CloneWorkspaceInit =>
      new CloneWorkspaceInitStep(workspaceManagerDAO, workspaceRepository, monitorRecordDao, workspaceId, job)
    case JobType.CreateWdsAppInClonedWorkspace =>
      new CloneWorkspaceCreateWDSAppStep(leonardoDAO, workspaceRepository, monitorRecordDao, workspaceId, job)
    case JobType.CloneWorkspaceContainerInit =>
      new CloneWorkspaceStorageContainerInitStep(workspaceManagerDAO,
                                                 workspaceRepository,
                                                 monitorRecordDao,
                                                 workspaceId,
                                                 job
      )
    case JobType.CloneWorkspaceAwaitContainerResult =>
      new CloneWorkspaceAwaitStorageContainerStep(workspaceManagerDAO,
                                                  workspaceRepository,
                                                  monitorRecordDao,
                                                  workspaceId,
                                                  job
      )
    case _ =>
      throw new IllegalArgumentException(s"${this.getClass.getSimpleName} called with invalid job type: ${job.jobType}")
  }

}
