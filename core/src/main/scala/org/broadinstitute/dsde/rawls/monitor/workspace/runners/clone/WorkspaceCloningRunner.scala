package org.broadinstitute.dsde.rawls.monitor.workspace.runners.clone

import com.typesafe.scalalogging.LazyLogging
import org.broadinstitute.dsde.rawls.dataaccess.{GoogleServicesDAO, LeonardoDAO, SamDAO, WorkspaceManagerResourceMonitorRecordDao}
import org.broadinstitute.dsde.rawls.dataaccess.slick.WorkspaceManagerResourceMonitorRecord.{Complete, JobType}
import org.broadinstitute.dsde.rawls.dataaccess.slick.{WorkspaceManagerResourceJobRunner, WorkspaceManagerResourceMonitorRecord}
import org.broadinstitute.dsde.rawls.dataaccess.workspacemanager.WorkspaceManagerDAO
import org.broadinstitute.dsde.rawls.model.{AttributeBoolean, AttributeName, AttributeString, RawlsRequestContext, Workspace, WorkspaceRequest, WorkspaceState}
import org.broadinstitute.dsde.rawls.monitor.workspace.runners.UserCtxCreator
import org.broadinstitute.dsde.rawls.workspace.WorkspaceRepository

import java.util.UUID
import scala.concurrent.{ExecutionContext, Future}

object WorkspaceCloningRunner {

  val WORKSPACE_INITIAL_CLONE_JOBID_KEY = "WORKSPACE_INITIAL_CLONE_JOBID"
  val SOURCE_WORKSPACE_KEY = "SOURCE_WORKSPACE"
  val STORAGE_CONTAINER_CLONE_PREFIX_KEY = "STORAGE_CONTAINER_CLONE_PREFIX"
  val DISABLE_AUTOMATIC_APP_CREATION_KEY = "DISABLE_AUTOMATIC_APP_CREATION"

  // The jobId returned by WSM is the default job id generated by stairway
  // Currently, stairway generates this via a 'ShortUUID' which doesn't parse correctly
  // So for the time being, we need to add it as a job argument
  def buildCloningArgs(sourceWorkspace: Workspace, initialJobId: String, request: WorkspaceRequest): Map[String, String] = {
    val disableAutoAppCreate =
      request.attributes.get(AttributeName.withDefaultNS("disableAutomaticAppCreation")) match {
      case Some(AttributeString("true")) | Some(AttributeBoolean(true)) => "true"
      case _ => "false"
    }

    val args = Map(
      WORKSPACE_INITIAL_CLONE_JOBID_KEY -> initialJobId,
      SOURCE_WORKSPACE_KEY -> sourceWorkspace.workspaceIdAsUUID.toString,
      DISABLE_AUTOMATIC_APP_CREATION_KEY -> disableAutoAppCreate
    )

    request.copyFilesWithPrefix match {
      case Some(prefix) => args + (STORAGE_CONTAINER_CLONE_PREFIX_KEY -> prefix)
      case None => args
    }
  }

  def getInitialWSMJobId(args: Option[Map[String, String]]): Option[String] =
    args.flatMap(argsMap => argsMap.get(STORAGE_CONTAINER_CLONE_PREFIX_KEY))

  def isAutomaticAppCreationDisabled(args: Option[Map[String, String]]): Boolean =
    args.flatMap(argsMap => argsMap.get(DISABLE_AUTOMATIC_APP_CREATION_KEY)).getOrElse("false") == "true"

  def getSourceWorkspaceId(args: Option[Map[String, String]]): Option[UUID] =
    args.flatMap(argsMap => argsMap.get(SOURCE_WORKSPACE_KEY)).map(id => UUID.fromString(id))

  def getStorageContainerClonePrefix(args: Option[Map[String, String]]): Option[String] =
    args.flatMap(argsMap => argsMap.get(STORAGE_CONTAINER_CLONE_PREFIX_KEY))
}


class WorkspaceCloningRunner(
                              val samDAO: SamDAO,
                              val gcsDAO: GoogleServicesDAO,
                              leonardoDAO: LeonardoDAO,
                              workspaceManagerDAO: WorkspaceManagerDAO,
                              monitorRecordDao: WorkspaceManagerResourceMonitorRecordDao,
                              workspaceRepository: WorkspaceRepository,
                            ) extends WorkspaceManagerResourceJobRunner
  with LazyLogging
  with UserCtxCreator {


  def cloneFail(wsId: UUID, message: String)(implicit executionContext: ExecutionContext): Future[Int] =
    workspaceRepository.setFailedState(wsId, WorkspaceState.CreateFailed, message)


  override def apply(job: WorkspaceManagerResourceMonitorRecord)(implicit
                                                                 executionContext: ExecutionContext
  ): Future[WorkspaceManagerResourceMonitorRecord.JobStatus] = {
    def logFailure(msg: String, t: Option[Throwable] = None): Unit = {
      val logMessage = s"CloneWorkspace monitoring job with id ${job.jobControlId} failed: $msg"
      t match {
        case Some(t) => logger.error(logMessage, t)
        case None => logger.error(logMessage)
      }
    }

    val workspaceId = job.workspaceId match {
      case Some(id) => id
      case None =>
        logger.error(
          s"Job to monitor workspace deletion created with id ${job.jobControlId} but no workspace ID"
        )
        return Future.successful(Complete)
    }

    val userEmail = job.userEmail match {
      case Some(email) => email
      case None =>
        val msg =
          s"Unable to update clone status for workspace $workspaceId because no user email set on monitoring job"
        logFailure(msg)
        return cloneFail(workspaceId, msg).map(_ => Complete)
    }

    for {
      userCtx <- getUserCtx(userEmail)
      step = job.jobType match {
        case JobType.CloneWorkspaceInit =>
          new CloneWorkspaceInitStep(workspaceManagerDAO, workspaceRepository, monitorRecordDao, workspaceId, job)
        case JobType.CreateWdsAppInClonedWorkspace =>
          new CloneWorkspaceCreateWDSAppStep(leonardoDAO, workspaceRepository, monitorRecordDao, workspaceId, job)
        case JobType.CloneWorkspaceContainerInit =>
          new CloneWorkspaceStorageContainerInitStep(workspaceManagerDAO, workspaceRepository, monitorRecordDao, workspaceId, job)
        case JobType.CloneWorkspaceContainerResult =>
          new CloneWorkspaceAwaitStorageContainerStep(workspaceManagerDAO, workspaceRepository, monitorRecordDao, workspaceId, job)
        case _ =>
          throw new IllegalArgumentException(s"${this.getClass.getSimpleName} called with invalid job type: ${job.jobType}")
      }
      status <- step.runStep(userCtx)
    } yield status
  }


}











